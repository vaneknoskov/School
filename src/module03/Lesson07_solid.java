package module03;

public class Lesson07_solid {
    public static void main(String[] args) {
        /* 1. SOLID нужен для правильного построения структуры приложения, что бы в дальнешей разработке
        приложения, его можно было бы легче модефицировать или расширять.
           2. Принцип единственной ответственности (SRP). Насколько уж я понял, если у нас есть класс
           который может измениться по нескольким причинам, то лучше будет разбить этот класс на несколько,
           что бы у каждого класса была своя ответственность.
           3. Принцип открытости/закрытости (OCP).
           Наш код можно только расширять, но не изменять.
           Принцип открытости/закрытости Мейера.
           Написанную реализацию класса в дальнейшем нужно только исправлять от ошибок, а уже все новое
           нужно добавлять через создание новых классов.
           Молиморфный принцип открытости/закрытости.
           Тут я пока не особо догнал, как пойму , дополню этот фрагмент.
           4. Принцип подстановки Лискова (LSP).
           Наследующий класс должен дополнять, а не изменять базовый. Более простым языком, если мы где то
           наследуем класс, то допустим переопределяя метод наследуемого класса, мы должны дополнить его,
           что бы он выполнял ожидаемую реализацию, допустим возрашал тот же тип данных что и базовый,
           а не изменял его. Например базовый возращает true или false, значит и наследующий тоже должен
           возращять такой же тип данных без изменений.
           5. Принцип разделения интерфейса (ISP).
           Вместо одного большого интерфейса, лучше разбить его на несколько мелких.
           Например если есть инрфейс отвечающий за подсветку клавиатуры , мышки и видеокарты, то его
           желательно разбить на три более спецефичных интерфейса.
           6. Принцип инверсии зависимостей (DIP).
           Модули верхних уровней, не должны зависеть от модулей нижних уровней. Оба типа должны быть зависемы
           от абстракций.
           Вместо того что бы класс А ипсользовал у себя метод из класса B, лучше вместо класса B использовать
           интерфейс , что бы при малейшем изменении в классе В, у нас не произошкла беда в классе А.
           7. Ну не то бы прям обязаны наверное, но я думаю что должны, так как если мы будем следовать этим принципам, то
           разработка приложения на всех этапах облегчится, как для нас, так и для всех, кто каким либо образом
           связан с нашим проектом, как в настоящее время, так и в будущем при его расширении.


        * */
    }
}
